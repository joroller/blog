# 迭代器模式

## 定义

**迭代器模式**提供一种方法来顺序访问一个聚合对象（聚合对象可以理解为一个容器）中的各个元素，而又不暴露其内部的表示。
即不同的容器，有不同的遍历方式，但使用迭代器模式后，会将所有的遍历操作都封装到相同的接口中，用户只需要调用这些接口就可以遍历容器中的对象。

## 无模式举例

### 前提

假设现有两种菜单：水果类菜单 与 蔬菜类菜单。

水果类菜单类名为 `FruitMenu.class`，底层使用数组类保存菜单项。

| 菜单项   | 价格 |
| --------| -----|
| apple   | 1    |
| banana  | 1    |

蔬菜类菜单，类名为 `VegetableMenu.class`，底层使用列表保存菜单项。

| 菜单项   | 价格  |
| --------| ----- |
| duck    | 10    |
| pork    | 15    |

### 代码

两种菜单的 class 如下：

`FruitMenu.class`:
```java
package nopattern;

import withpattern.MenuItem;

public class FruitMenu {
  private MenuItem[] menuItems;

  public FruitMenu() {
    MenuItem apple = new MenuItem("apple", 1);
    MenuItem banana = new MenuItem("banana", 2);
    MenuItem[] items = {apple, banana};
    this.menuItems = items;
  }

  public MenuItem[] getMenuItems() {
    return menuItems;
  }
}
```

`VegetableMenu.class`:
```java
package nopattern;

import withpattern.MenuItem;
import java.util.ArrayList;
import java.util.List;

public class VegetableMenu {

  private List<MenuItem> menuItems;

  public VegetableMenu() {
    List<MenuItem> menuItems = new ArrayList<>();
    menuItems.add(new MenuItem("duck", 10));
    menuItems.add(new MenuItem("pork", 15));
    this.menuItems = menuItems;
  }

  public List<MenuItem> getMenuItems() {
    return menuItems;
  }
}
```

`MenuItem.class`
```java
package common;

public class MenuItem {
  private String name;
  private int price;

  public MenuItem(String name, int price) {
    this.name = name;
    this.price = price;
  }

  @Override
  public String toString() {
    return "common.MenuItem{" +
            "name='" + name + '\'' +
            ", price=" + price +
            '}';
  }
}

```

现在需要将这两类菜单进行遍历，遍历代码如下：

`Client.class`:
```java
package nopattern;

import withpattern.MenuItem;
import java.util.List;

public class Client {

  public static void main(String[] args) {
    // 获取水果类菜单的菜单项
    FruitMenu fruitMenu = new FruitMenu();
    MenuItem[] fruitMenuItems = fruitMenu.getMenuItems();
    // 遍历并打印菜单项（假设只能使用传统 for 循环来遍历菜单项）
    for(int i = 0; i < fruitMenuItems.length; i++) {
      MenuItem item = fruitMenuItems[i];
      System.out.println(item);
    }

    // 获取蔬菜类菜单的菜单项
    VegetableMenu vegetableMenu = new VegetableMenu();
    List<MenuItem> vegetableMenuItems = vegetableMenu.getMenuItems();

    // 遍历并打印菜单项（假设只能使用传统 for 循环来遍历菜单项）
    for(int i = 0; i < vegetableMenuItems.size(); i++) {
      MenuItem item = vegetableMenuItems.get(i);
      System.out.println(item);
    }
  }
}

```
### 思考

以上代码中我们使用了两种容器来保存菜单项 - 数组 与 列表。
针对这两种容器我们又使用了两种遍历方式（虽然都是 for 循环，但代码不完全一样）。

那么，有没有一种可能性可以将这两种不同的遍历的代码进行统一呢？

答案是肯定的，接下来我们将使用**迭代器**模式来实现这一目标。

## 使用迭代器模式

### Iterator.class

要使用迭代器模式，我们可以借助 Java 已经提供的 `Iterator.class` 接口，它提供了如下方法：

`Iterator.class`
```java
package java.util;

import java.util.function.Consumer;

public interface Iterator<E> {
  // 判断容器中是否还有下一个元素
  boolean hasNext();

  // 返回容器中下一个元素对象
  E next();

  // 删除容器中的下一个元素，默认是抛出异常，如果需要，子类可以执行重写
  default void remove() {
    throw new UnsupportedOperationException("remove");
  }

  // 遍历并执行指定的行为，该行为由一个 lambda 表达式来定义，下文将会举例如何使用该方法 
  default void forEachRemaining(Consumer<? super E> action) {
    Objects.requireNonNull(action);
    while (hasNext())
      action.accept(next());
  }
}
```
### 代码

接下来我们将为上面两种菜单各自实现一个迭代器（以上两种菜单对应的 class 不需要改变，遵守了**开闭原则**）:

`FruitMenuIterator.class`
```java
package withpattern1;

import common.MenuItem;
import java.util.Iterator;

public class FruitMenuIterator implements Iterator<MenuItem> {

  private MenuItem[] menuItems;

  private int position;

  public FruitMenuIterator(FruitMenu fruitMenu) {
    this.menuItems = fruitMenu.getMenuItems();
  }

  @Override
  public boolean hasNext() {
    if(menuItems.length == 0 || menuItems == null) {
      return false;
    }
    return position < menuItems.length;
  }

  @Override
  public MenuItem next() {
    MenuItem nextItem = menuItems[position];
    position += 1;
    return nextItem;
  }
}
```

`VegetableMenuIterator.class`
```java
package withpattern1;

import common.MenuItem;
import java.util.Iterator;
import java.util.List;

public class VegetableMenuIterator implements Iterator<MenuItem> {

  private List<MenuItem> menuItems;

  private int position;

  public VegetableMenuIterator(VegetableMenu vegetableMenu) {
    this.menuItems = vegetableMenu.getMenuItems();
  }

  @Override
  public boolean hasNext() {
    if(menuItems.size() == 0 || menuItems == null) {
      return false;
    }
    return position < menuItems.size();
  }

  @Override
  public MenuItem next() {
    MenuItem nextItem = menuItems.get(position);
    position += 1;
    return nextItem;
  }
}
```

`Client.class`
```java
package withpattern1;

import java.util.Iterator;

public class Client {

  public static void main(String[] args) {
    // 获取水果类菜单的菜单项
    FruitMenu fruitMenu = new FruitMenu();
    // 将类型声明为接口类型，遵守 针对接口编程 原则
    Iterator fruitMenuIterator = new FruitMenuIterator(fruitMenu);

    // 遍历并打印菜单项（使用迭代器）
    while(fruitMenuIterator.hasNext()) {
      System.out.println(fruitMenuIterator.next());
    }

    // 获取蔬菜类菜单的菜单项
    VegetableMenu vegetableMenu = new VegetableMenu();
    // 将类型声明为接口类型，遵守 针对接口编程 原则
    Iterator vegetableMenuIterator = new VegetableMenuIterator(vegetableMenu);

    // 遍历并打印菜单项（使用迭代器）
    while(vegetableMenuIterator.hasNext()) {
      System.out.println(vegetableMenuIterator.next());
    }
  }
}
```
可以看到，我们在遍历不同的菜单时，使用了一样的遍历代码，稍有不同的是变量名，但想要使代码一摸一样也很简单，只需要如下操作：

`Client.class`
```java

  ...

  FruitMenu fruitMenu = new FruitMenu();
  Iterator iterator = new FruitMenuIterator(fruitMenu);

  while(iterator.hasNext()) {
    System.out.println(iterator.next());
  }

  VegetableMenu vegetableMenu = new VegetableMenu();
  // 复用变量
  iterator = new VegetableMenuIterator(vegetableMenu);

  while(iterator.hasNext()) {
    System.out.println(iterator.next());
  }

  ...

```
**使用 forEachRemaining() 方法进行遍历**

```java
public static void main(String[] args) {
  // 获取水果类菜单的菜单项
  FruitMenu fruitMenu = new FruitMenu();
  Iterator fruitMenuIterator = new FruitMenuIterator(fruitMenu);
  // 遍历并打印菜单项
  fruitMenuIterator.forEachRemaining(item -> System.out.println(fruitMenuIterator.next()));

  // 获取蔬菜类菜单的菜单项
  VegetableMenu vegetableMenu = new VegetableMenu();
  Iterator vegetableMenuIterator = new VegetableMenuIterator(vegetableMenu);

  // 遍历并打印菜单项
  fruitMenuIterator.forEachRemaining(item -> System.out.println(vegetableMenuIterator.next()));
}
```
### 引入 Iterable.class

可以让我们的菜单类实现 `Iterable.class`，该类有一个 `iterator()` 方法，可以让菜单返回一个迭代器，这样我们就可以直接在菜单对象中直接调用该方法来获取迭代器，
而不需要再单独创建每种菜单所对应的迭代器。通过这个方法我们还可以将迭代器的实现给封装起来，客户端代码并不知道迭代器是如何创建的。

以下是 `Iterable.class` 提供的方法:

`Iterable.class`
```java
public interface Iterable<T> {
  // 返回一个迭代器，用于遍历容器中的元素
  Iterator<T> iterator();

  // 支持 forEach 语法糖循环遍历。或者直接调用该方法也可以遍历，需要使用 lambda 表达式来定义遍历时对元素进行的操作
  default void forEach(Consumer<? super T> action) {
    Objects.requireNonNull(action);
    for (T t : this) {
      action.accept(t);
    }
  }

  // 暂时未使用过，略
  default Spliterator<T> spliterator() {
    return Spliterators.spliteratorUnknownSize(iterator(), 0);
  }
```

接下来我们将改写 `FruitMenu.class`, `` 与 ``：

`FruitMenu.class`
```java
package withpattern2;

import common.MenuItem;
import java.util.Iterator;

public class FruitMenu implements Iterable<MenuItem> {
  private MenuItem[] menuItems;

  public FruitMenu() {
    MenuItem apple = new MenuItem("apple", 1);
    MenuItem banana = new MenuItem("banana", 2);
    MenuItem[] items = {apple, banana};
    this.menuItems = items;
  }

  public MenuItem[] getMenuItems() {
    return menuItems;
  }

  @Override
  public Iterator<MenuItem> iterator() {
    return new FruitMenuIterator(this);
  }
}
```

`VegetableMenu.class`
```java
package withpattern2;

import common.MenuItem;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class VegetableMenu implements Iterable<MenuItem> {

  private List<MenuItem> menuItems;

  public VegetableMenu() {
    List<MenuItem> menuItems = new ArrayList<>();
    menuItems.add(new MenuItem("duck", 10));
    menuItems.add(new MenuItem("pork", 15));
    this.menuItems = menuItems;
  }

  public List<MenuItem> getMenuItems() {
    return menuItems;
  }

  @Override
  public Iterator<MenuItem> iterator() {
    return new VegetableMenuIterator(this);
  }
}
```

`Client.class`
```java
package withpattern2;

import common.MenuItem;
import java.util.Iterator;

public class Client {

  public static void main(String[] args) {
    // 获取水果类菜单的菜单项
    FruitMenu fruitMenu = new FruitMenu();

    // 不需要单独再创建 FruitMenuIterator 迭代器对象了
    //Iterator fruitMenuIterator = new FruitMenuIterator(fruitMenu);

    // 直接通过菜单对象获取迭代器
    Iterator fruitMenuIterator = fruitMenu.iterator();
    // 遍历并打印菜单项（使用迭代器）
    while(fruitMenuIterator.hasNext()) {
      System.out.println(fruitMenuIterator.next());
    }
    // 使用 forEach 语法糖进行遍历
    for(MenuItem item : fruitMenu) {
      System.out.println(item);
    }
    // 调用 forEach 方法进行遍历
    fruitMenu.forEach(item -> System.out.println(item));


    // 获取蔬菜类菜单的菜单项
    VegetableMenu vegetableMenu = new VegetableMenu();

    // 不需要单独再创建 VegetableMenuIterator 迭代器对象了
    //Iterator vegetableMenuIterator = new VegetableMenuIterator(vegetableMenu);

    // 直接通过菜单对象获取迭代器
    Iterator vegetableMenuIterator = vegetableMenu.iterator();
    // 遍历并打印菜单项（使用迭代器）
    while(vegetableMenuIterator.hasNext()) {
      System.out.println(vegetableMenuIterator.next());
    }
    // 使用 forEach 语法糖进行遍历
    for(MenuItem item : vegetableMenu) {
      System.out.println(item);
    }
    // 调用 forEach 方法进行遍历
    vegetableMenu.forEach(item -> System.out.println(item));
  }
}
```

通过 `Client.class` 中的代码可以看到，实现了 `Iterable.class` 接口后，
我们的菜单不仅可以通过迭代器来遍历，同时也支持了 forEach 语法糖，或者直接调用 forEach 来遍历。 

### 思考

既然我们实现了 `Iterable.class` 接口并将菜单所以应的迭代器的创建给封装起来了，那么我们就不需要将 `FruitMenuIterator.class` 和 `VegetableMenuIterator.class` 暴露给客户端代码。
那么我们是否可以优化呢？

答案是肯定的，我们可以通过权限访问与内部类来实现，接下来我们将实现代码的最终版本。

## 代码的最终优化

`Menu.class`
```java
package withpattern;

import common.MenuItem;

// 抽象菜单为接口，并继承 Iterable 接口
public interface Menu extends Iterable<MenuItem> {}

```

`FruitMenu.class`
```java
package withpattern;

import common.MenuItem;

import java.util.Iterator;

// 实现 Menu 接口
public class FruitMenu implements Menu {
  // 使用数组来保存菜单项
  private MenuItem[] menuItems;

  public FruitMenu(MenuItem[] menuItems) {
    this.menuItems = menuItems;
  }

  // 此方法可以不需要，因为已经又迭代器可以提供遍历了，不需要再通过数组来遍历
  public MenuItem[] getMenuItems() {
    return menuItems;
  }

  @Override
  public Iterator<MenuItem> iterator() {
    // 创建并返回迭代器
    return new FruitMenuIterator();
  }

  // 私有的类，对外只会暴露出它是一个 Iterator 类型的对象
  private class FruitMenuIterator implements Iterator {

    private int position;

    // 私有的构造方法，外界无法创建该对象，只有在 FruitMenu 类的范围中可以创建
    private FruitMenuIterator() {}

    @Override
    public boolean hasNext() {
      // 非静态内部类可以访问外部类的 menuItems 实例变量
      if(menuItems.length == 0 || menuItems == null) {
        return false;
      }
      return position < menuItems.length;
    }

    @Override
    public MenuItem next() {
      MenuItem nextItem = menuItems[position];
      position += 1;
      return nextItem;
    }
  }
}
```

`VegetableMenu.class`
```java
package withpattern;

import common.MenuItem;
import java.util.Iterator;
import java.util.List;

// 实现 Menu 接口
public class VegetableMenu implements Menu {
  // 使用列表来保存菜单项
  private List<MenuItem> menuItems;

  public VegetableMenu(List<MenuItem> menuItems) {
    this.menuItems = menuItems;
  }

  @Override
  public Iterator iterator() {
    // 创建并返回迭代器
    return new FruitMenuIterator();
  }

  // 私有的类，对外只会暴露出它是一个 Iterator 类型的对象
  private class FruitMenuIterator implements Iterator {

    private int position;

    // 私有的构造方法，外界无法创建该对象，只有在 VegetableMenu 类的范围中可以创建
    private FruitMenuIterator() {}

    @Override
    public boolean hasNext() {
      // 非静态内部类可以访问外部类的 menuItems 实例变量
      if(menuItems.size() == 0 || menuItems == null) {
        return false;
      }
      return position < menuItems.size();
    }

    @Override
    public MenuItem next() {
      MenuItem nextItem = menuItems.get(position);
      position += 1;
      return nextItem;
    }
  }
}
```

`MenuFactory.class`
```java
package withpattern;

import common.MenuItem;
import java.util.ArrayList;
import java.util.List;

// 静态工厂，封装菜单 new 的操作
public class MenuFactory {

  public static Menu getMeatMenu() {
    MenuItem apple = new MenuItem("apple", 1);
    MenuItem banana = new MenuItem("banana", 2);
    MenuItem[] items = {apple, banana};

    Menu fruitMenu = new FruitMenu(items);
    return fruitMenu;
  }

  public static Menu getVegetableMenu() {
    MenuItem carrot = new MenuItem("carrot", 3);
    MenuItem cabbage = new MenuItem("cabbage", 2);
    List<MenuItem> items = new ArrayList<>();
    items.add(carrot);
    items.add(cabbage);

    Menu vegetableMenu = new VegetableMenu(items);
    return vegetableMenu;
  }
}
```

`Client.class`
```java
package withpattern;

import common.MenuItem;
import java.util.Iterator;

// 测试
public class Client {

  public static void main(String[] args) {
    Menu meatMenu = MenuFactory.getMeatMenu();

    // 遍历方式1： 通过迭代器
    Iterator<MenuItem> meatMenuIterator = meatMenu.iterator();
    while (meatMenuIterator.hasNext()) {
      System.out.println(meatMenuIterator.next());
    }
    // 遍历方式2： 通过迭代器的 forEachRemaining() 方法
    meatMenu.iterator().forEachRemaining(item -> System.out.println(item));
    // 遍历方式3： 通过迭代器的 forEach 语法糖
    for(MenuItem item : meatMenu) {
      System.out.println(item);
    }
    // 遍历方式4： forEach() 方法
    meatMenu.forEach(item -> System.out.println(item));


    Menu vegetableMenu = MenuFactory.getVegetableMenu();

    Iterator<MenuItem> vegetableMenuIterator = vegetableMenu.iterator();
    while (vegetableMenuIterator.hasNext()) {
      System.out.println(vegetableMenuIterator.next());
    }

    vegetableMenu.iterator().forEachRemaining(item -> System.out.println(item));

    for(MenuItem item : vegetableMenu) {
      System.out.println(item);
    }

    vegetableMenu.forEach(item -> System.out.println(item));
  }
}
```

## Java 中对迭代器的使用举例

### ArrayList 中的迭代器

`ArrayList.class`
```java
import java.util.*;
import java.util.function.Consumer;

// 继承 AbstractList.class，AbstractList.class 往上追踪，会发现其实现了 Iterable.class
public class ArrayList<E> extends AbstractList<E> {

  private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

  transient Object[] elementData;

  private int size;

  protected transient int modCount = 0;

  public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
  }

  // 重写 AbstractList.iterator() 方法，
  // 使用 ArrayList.class 自身提供的内部类 Itr.class 来创建迭代器实例
  public Iterator<E> iterator() {
    return new Itr();
  }

  public boolean add(E e) {
    ensureCapacityInternal(size + 1);
    elementData[size++] = e;
    return true;
  }

  public boolean remove(Object o) {
    // ...
  }

  // ...

  // 私有的内部类，实现了 Iterator.class
  private class Itr implements Iterator<E> {
    int cursor;       // 下一个将返回元素的下标
    int lastRet = -1; // 上一个被返回元素的下标，-1 代表没有返回过元素
    int expectedModCount = modCount;

    Itr() {}

    public boolean hasNext() {
      return cursor != size;
    }

    @SuppressWarnings("unchecked")
    public E next() {
      checkForComodification();
      int i = cursor;
      if (i >= size)
        throw new NoSuchElementException();
      Object[] elementData = ArrayList.this.elementData;
      if (i >= elementData.length)
        throw new ConcurrentModificationException();
      // 更新下标增加1
      cursor = i + 1;
      return (E) elementData[lastRet = i];
    }

    public void remove() {
      if (lastRet < 0)
        throw new IllegalStateException();
      checkForComodification();

      try {
        // 通过 ArrayList.this 调用外部 ArrayList 实例对象
        ArrayList.this.remove(lastRet);
        cursor = lastRet;
        lastRet = -1;
        expectedModCount = modCount;
      } catch (IndexOutOfBoundsException ex) {
        throw new ConcurrentModificationException();
      }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void forEachRemaining(Consumer<? super E> consumer) {
      Objects.requireNonNull(consumer);
      final int size = ArrayList.this.size;
      int i = cursor;
      if (i >= size) {
        return;
      }
      final Object[] elementData = ArrayList.this.elementData;
      if (i >= elementData.length) {
        throw new ConcurrentModificationException();
      }
      while (i != size && modCount == expectedModCount) {
        consumer.accept((E) elementData[i++]);
      }
      // update once at end of iteration to reduce heap write traffic
      cursor = i;
      lastRet = i - 1;
      checkForComodification();
    }

    // ...
  }
}
```

## 参考

Head First - 设计模式
