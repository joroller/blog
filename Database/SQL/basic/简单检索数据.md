# 简单检索数据

## 1. SELECT 语句

```
SELECT 单/多列名 FROM 表名;
```

## 1.1 检索单列

```
SELECT prod_name FROM products;
```

## 1.2 检索多列

```
SELECT prod_id, prod_name FROM products;
```

## 1.3 检索所有列

```
SELECT * FROM products;
```

## 1.4 检索结果不重复

使用 DISTINCT 参数。

```
SELECT DISTINCT prod_name FROM products;
```

## 1.5 检索特定范围的结果

### 1.5.1 返回前 n 条数据

#### 原生SQL

```
SELECT TOP n prod_name FROM products;
```

#### DB2

```
SELECT prod_name FROM products FETCH n ROWS ONLY;
```

#### Oracle

```
SELECT prod_name FROM products WHERE ROWNUM <= n;
```

#### MySQL、MariaDB、PostgreSQL或SQLite

```
SELECT prod_name FROM products LIMIT n;
```
当不足 n 条数据时，只返回仅有的数据。例如只有3条数据，则只返回这3条。

### 1.5.2 返回某一范围数据

#### MySQL、MariaDB、PostgreSQL或SQLite

```
SELECT prod_name FROM products LIMIT n OFFSET n1;
```

简化版本

```
SELECT prod_name FROM products LIMIT n1,n;
```

从 n1 行（起始行为0）开始，返回其后的 n 条数据。当不足 n 条数据时，只返回仅有的数据。例如只有3条数据，则只返回这3条。

因为 n1 是从 0 开始的，那么 `SELECT prod_name FROM products LIMIT 2 OFFSET 1;` 会得到第2、3行的数据。


## 2. ORDER BY 子句排序数据

```
SELECT 单/多列名 FROM 表名 ORDER BY 单/多列名;
```

### 2.1 单列排序

按列名排序
```
SELECT prod_name FROM products ORDER BY prod_name;
```

按列的位置排序
```
SELECT prod_name FROM products ORDER BY p;
```

e.g. 假设 prod_name 列在第 2 列，`SELECT prod_name FROM products ORDER BY 2;`

### 2.2 多列排序

按列名排序
```
SELECT prod_name, prod_id FROM products ORDER BY prod_name, prod_id;
```

按列的位置排序
```
SELECT prod_name, prod_id FROM products ORDER BY p1, p2;
```

### 2.3 指定排序方向

单列
```
SELECT 单/多列名 FROM 表名 ORDER BY 列名 ASC/DESC;
```

多列
```
SELECT 单/多列名 FROM 表名 ORDER BY 列名1 ASC/DESC， 列名2 ASC/DESC;
```
ASC - 升序(可不写，默认)

DESC - 降序

## 3. WHERE 子句过滤数据

```
SELECT 单/多列名 FROM 表名 WHERE 条件;
```

```
SELECT 单/多列名 FROM 表名 WHERE 条件 ORDER BY 子句;
```

### 3.1 操作符

以下操作符并非所有 DBMS 都支持。

    =       等于
    <>      不等于
    !=      不等于
    <       小于
    <=      小于等于
    !<      不小于
    />      大于
    >=      大于等于
    !>      不大于
    BETWEEN n1 AND n2   在指定的两个值之间
    IS NULL             为 NULL 值
    IS NOT NULL         为非 NULL 值

当与字符串比较时，需要用单引号包含该字符串

```
SELECT vend_id, prod_name FROM products WHERE vend_id = 'DLL01'
```

### 3.2 组合 WHERE 子句

#### 3.2.1 AND 操作符

```
SELECT 单/多列名 FROM 表名 WHERE 条件1 AND 条件2;
```

#### 3.2.2 OR 操作符

```
SELECT 单/多列名 FROM 表名 WHERE 条件1 OR 条件2;
```

#### 3.3.3 求值顺序

WHERE 子句可以包含任意数目的 AND 和 OR 操作符。允许两者结合以进行复杂、高级的过滤。
其中 AND 操作符的优先级比 OR 操作符的优先级更高。

例如：

`SELECT prod_name, prod_price FROM products WHERE vend_id = 'DLL01' OR VEND_ID = 'BRS01' AND prod_price >= 10;`

该语句并不会先执行 `vend_id = 'DLL01' OR VEND_ID = 'BRS01'` 然后在得到的结果中过滤 `prod_price >= 10` 的数据。
而真实的执行顺序是先执行 `VEND_ID = 'BRS01' AND prod_price >= 10` 然后在得到的结果中过滤 `vend_id = 'DLL01'` 的数据。

要解决这个因为操作符优先级引起的问题，可以使用一对圆括号 () 来提高优先级。

解决：

`SELECT prod_name, prod_price FROM products WHERE (vend_id = 'DLL01' OR VEND_ID = 'BRS01') AND prod_price >= 10;`

#### 3.3.4 IN 操作符

```
SELECT 单/多列名 FROM 表名 WHERE 列名 IN (值1， 值2);
```

IN 操作符与 OR 操作符完全相同，那么为什么要使用 IN 操作符呢？其有点如下：

* 在有很多合法选项时，IN 操作符的语法更清楚，更直观。
* 在与其他 AND 和 OR 操作符组合使用 IN 时，求值顺序更容易管理。
* IN 操作符一般比一组 OR 操作符执行得更快。
* IN的最大有点是可以包含其它 SELECT 语句，能够更动态地建立 WHERE 子句。这里的动态指的是不需要提前知道有哪些合法选项，而这些合法选项只有在执行了子句后才能知道。  

#### 3.3.5 NOT 操作符

```
SELECT 单/多列名 FROM 表名 WHERE NOT 条件;
```

## 4. 通配符过滤

### 4.1 LIKE 操作符

只能用于文本字段（字符串），非文本数据类型字段不能使用通配符来搜索数据。另外它不区分大小写，具体如何区分大小写需要查看各自DBMS。

```
SELECT 单/多列名 FROM 表名 WHERE 列名 LIKE 搜索模式
```

搜索模式 - 由字面值、通配符或两者组合构成的搜索条件。

#### 4.1.1 百分号通配符（%）

% 表示任何字符出现任意次数（包括0次）。
% 不能匹配 NULL。

* 匹配列中以 'xxx' 开头的数据：

```
SELECT 单/多列名 FROM 表名 WHERE 列名 LIKE 'xxx%'
```

例如：

‘abc%' - 可以匹配 ’abc‘、'abcd'、'abcde'、’ABCD‘ 等

* 匹配列中以 'xxx' 结尾的数据：

```
SELECT 单/多列名 FROM 表名 WHERE 列名 LIKE '%xxx'
```

例如：

‘%abc' - 可以匹配 ’abc‘、'dabc'、'deabc'、’DABC‘ 等

* 匹配列中包含 'xxx' 的数据：
  
该搜索模式会匹配包括符合以上两种情况的数据。

```
SELECT 单/多列名 FROM 表名 WHERE 列名 LIKE '%xxx%'
```

例如：

‘%abc%' - 可以匹配 ’abc‘、'abcd'、'abced'、’ABCD‘、'dabc'、'deabc'、’DABC‘ 等

* 匹配列中以 'xxx' 开头并以 ’yyy‘ 结尾的数据：

```
SELECT 单/多列名 FROM 表名 WHERE 列名 LIKE 'xxx%yyy'
```

例如：

‘a%d' - 可以匹配 ’ad‘、'abd'、'abcd'、’AD‘ 等

注意：有些 DBMS 用空格来填补字段内容，例如规定某列的字符串长度为50，那么在储存 ’abc‘ 时，会自动为 ’abc‘ 后面补47个空格。这样的数据会影响该搜索模式。 

#### 4.1.2 下划线通配符（_）

_ 与 % 类似，但它只匹配单个字符，而不是多个字符。

并不是所有 DBMS 都支持该通配符。

例如：

‘abc_' - 可以匹配 'abcd'、’ABCD‘ 等

#### 4.1.3 方括号通配符（[]）

[] 通配符用来指定一个字符集，它必须匹配指定位置（通配符的位置）的一个字符。

并不是所有 DBMS 都支持该通配符。

例如：

‘ab[cd]e' - 可以匹配 'abce'、'abde'、’ABCE‘、’ABDE‘ 等

[] 通配符还可以使用 ^ 来否定。

例如：

‘ab[^cd]e' - 不能可以匹配 'abce'、'abde'、’ABCE‘、’ABDE‘ 等

### 4.2 使用通配符的技巧

SQL 的通配符很有用，但这种功能是有代价的，即通配符搜索一般比其它的搜索要耗费更长的处理时间。下面是一些使用通配符的技巧：

* 不要过度使用通配符。如果其它操作符能达到相同的目的，应该使用其它操作符。
* 在确实需要使用通配符时，也尽量不要把它用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。
* 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。

## 5. 创建计算字段

字段 - 基本上与列的意思相同，进场互换使用，不过数据库列一般称为列，而字段这个术语通常在计算字段这种场合下使用。

```
SELECT 新字段计算表达式 AS 新字段别名 FROM 表名
```

### 5.1 拼接字段计算

由多个现有的列拼接成的新的字段。拼接符号为 + 或 ||。

```
SELECT 新字段拼接表达式  AS 新字段别名 FROM 表名
```

例如：

新字段拼接表达式： vend_name + '(' + vend_country + ')'

结果： Apple(USA)

如果在 Apple 后面有空格（部分数据库会自动填充空格来满足列宽），那么可以使用 RTrim() 函数来去掉后面的空格。

**注意： 不同的 DBMS 使用的符号不一样**

- SQL Server 使用 +

- DB2、Oracle、PostgreSQL 和 SQLite 使用 ||

vend_name || '(' || vend_country || ')'

- MySQL 和 MariaDB 使用 Concat() 函数

Concat(vend_name , '(' , vend_country , ')')

### 5.2 算术计算

对现有的列进行算术计算，得到一个新的字段。

```
SELECT 新字段算术达式 AS 新字段别名 FROM 表名
```

SQL 算术操作符有：

* \+  加
* \- 减
* \* 乘
* /  除

## 6. 使用函数处理数据

不同的 DBMS 可能有不同的函数来完成同一件事情。

### 6.1 文本处理函数

* Left() - Left(vend_name, 1) - 返回 vend_name 左边的 1 个字符
* Length() - Length(vend_name) - 返回 vend_name 的字符串长度
* Lower() - Lower(vend_name) - 返回全小写的 vend_name
* LTrim() - LTrim(vend_name) - 去掉 vend_name 左边的空格
* Right() - Right(vend_name, 1) - 返回 vend_name 右边的 1 个字符
* RTrim() - RTrim(vend_name) - 去掉 vend_name 右边的空格
* Substr() 或 Substring() - Substr(vend_name, 1, 2) - 在 vend_name 的第 1 个字符串开始取 2 个长度的子字符串。最后一个参数省略时会取到末尾。在该函数中第一个字符串的位置为 1 而不是 0
* Soundex() - Soundex('Roller') - 返回 Roller 的发音，这个用于对比两个字符串的发音是否类型
* Upper() - Upper(vend_name) - 返回全大写的 vend_name

### 6.2 日期和事件处理函数

不同的 DBMS 提供不同的函数。

### 6.3 数值处理函数

数值处理函数仅处理数值数据。

* ABS() - 绝对值
* COS() - 余弦
* EXP() - 指数
* PI() - π
* SIN() - 正弦
* SQRT() - 平方根
* TAN() - 正切

### 6.4 聚集函数

* AVG() - 返回某列的平均值。
* COUNT - 返回某列的行数
* MAX() - 返回某列的最大值
* MIN() - 返回某列的最小值
* SUM() - 返回某列值的和

```
SELECT 聚集函数 AS 字段别名 FROM 表名 WHERE 条件;
```

#### 6.4.1 AVG() 函数

AVG() 函数会忽略值为 NULL 的行。

#### 6.4.2 COUNT() 函数

COUNT() 函数有两种使用方式：

* COUNT(*) - 统计表中的行数，不管表列中包含的是 NULL 还是非空值
* COUNT(column_name) - 统计特定列中具有值的行数，忽略 NULL 值

#### 6.4.3 MAX() 函数

MAX() 函数会忽略值为 NULL 的行。

部分 DBMS 允许对非数字进行求最大值，返回的结果为排序后的最后一行。

#### 6.4.4 MIN() 函数

MIN() 函数会忽略值为 NULL 的行。

部分 DBMS 允许对非数字进行求最小值，返回的结果为排序后的最前一行。

#### 6.4.6 SUM() 函数

SUM() 函数会忽略值为 NULL 的行。

#### 6.4.7 聚集不同值

所有的聚集函数都可以如下使用：

* 指定 ALL 参数或不指定参数（因为 ALL 是默认行为）
* 使用 DISTINCT 参数

```
SELECT 聚集函数(ALL/DISTINCT 列名/表达式) AS 新字段名 FROM 表名 WHERE 条件;
```

注意：

* DISTINCT 不能用于 COUNT(*)
* DISTINCT 可用于 COUNT(column_name)
* DISTINCT 是可以用于 MIN() 和 MAX() 函数的，但这样做没有意义

#### 6.4.8 组合聚集函数

```
SELECT 聚集函数1 AS 别名1, 聚集函数2 AS 别名2, ... FROM 表名;
```

## 7. 分组数据

### 7.1 GROUP BY 分组子句

```
SELECT 列/新字段 FROM 表名 GROUP BY 列/新字段名;
```

???当执行 GROUP BY 子句时，会先排序然后再分组，所 GROUP BY 自带了排序的功能，但不能过分依赖这个功能。

使用 GROUP BY 的一些重要规定：

* GROUP BY 子句可以包含任意数目的列，因而可以对分组进行嵌套，更细致地进行数据分组。
* 如果在 GROUP BY 子句中嵌套了分组，数据将在最后指定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别列取回数据）。
* GROUP BY 子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在 SELECT 中使用表达式，则必须在 GROUP BY 子句中指定相同的表达式。不能使用别名。???（需要进一步验证）
* 大多数 SQL 实现不允许 GROUP BY 列带有长度可变的数据类型（如文本或备注型字段）。
* 除聚集计算语句外，SELECT 语句中的每一列都必须在 GROUP BY 子句中给出。
* 如果分组列中包含具有 NULL 值的行，则 NULL 将作为一个分组返回。如果列中有多行 NULL 值，它们将分为一组。
* GROUP BY 子句必须出现在 WHERE 子句之后，ORDER BY 子句之前。

### 7.2 HAVING 过滤分组子句

HAVING 由于对组的过滤，必须和 GROUP BY 搭配使用。

```
SELECT 列/新字段 FROM 表名 GROUP BY 列/新字段名 HAVING 条件;
```

### 7.4 分组合排序

一般在使用 GROUP BY 子句时，应该也给出 ORDER BY 子句。这是保证数据正确排序的唯一方法。千万不要仅依赖 GROUP BY 排序数据。

## 8. SELECT 子句顺序

|  子句     | 说明                   | 是否必须使用             |
|  ----     | ----                  | ----------             |
| SELECT    | 要返回的列或表达式       | 是                     |
| FROM      | 从中检索数据的表         | 仅在从表中选择数据时使用   |
| WHERE     | 行级过流程              | 否                     |
| GROUP BY  | 分组                   | 仅在按组计算聚集时使用     |
| HAVING    | 组级过滤                |  否                    |
| ORDER BY  | 输出排序顺序             | 否                     |
