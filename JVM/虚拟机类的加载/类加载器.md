# 类加载器

通过类的全限定名来获取该类的二进制字节流，实现这一动作的代码被称为“类加载器”。通俗来讲，它负责将.class文件的字节码形式转换成内存形式的Class对象。字节码可以来自于磁盘文件 *.class，也可以是 jar 包里的 *.class，也可以来自远程服务器提供的字节流，字节码的本质就是一个字节数组[]byte，它有特定的复杂的内部格式。

## 导航

[toc]

## ClassLoader类
抽象类，不能被创建对象。如果要自定义类加载器，则需要继承该类，必要条件下需要重写其中的某些方法。ClassLoader类中有三个重要的方法`loadClass(...)`、`findClass()` 和 `defineClass()`。

### 延迟加载

JVM运行并不是一次性加载所需要的全部类的，它是按需加载，也就是延迟，加载时机详见 [类加载时机](./类加载时机.md) 。程序在运行的过程中会逐渐遇到很多不认识的新类，这时候就会调用类加载器来加载这些类。加载完成后，如果下次要使用相同的类，则不需要重新加载了。

## 自定义类加载器

### 自定义类加载器的用处

有很多字节码加密技术就是依靠定制ClassLoader来实现的。先使用工具对字节码文件进行加密，运行时使用定制的ClassLoader先解密文件内容再加载这些解密后的字节码。

可以通过`Class`对象来获取classLoader来识别当前类是由哪个`ClassLoader`加载的。

```java
public final class Class<T> {
    ...
    private final ClassLoader classLoader;
    ...
    public ClassLoader getClassLoader() {
        ClassLoader cl = getClassLoader0();
        ...
        return cl;
    }
    ...
    ClassLoader getClassLoader0() { return classLoader; }
}
```

### loadClass(...)方法

#### 源码解读

`loadClass(...)`方法有两个重载类，分别为：

    loadClass(String name)
    loadClass(String name, boolean resolve)

`loadClass(String name)`只是简单的调用`loadClass(String name, boolean resolve)`方法，源代码如下：

```java
/*
使用指定类的二进制名称加载类。这个方法使用和 loadClass(String, boolean) 方法一样的方式去搜索类。它被 Java 虚拟机调用来解析类引用。调用此方法相当于调用 loadClass(name, false)。
Params:
    name – 类二进制名称
Returns:
    被加载后的 Class 对象
Throws:
    ClassNotFoundException – 如果类没有被找到
*/
public Class<?> loadClass(String name) throws ClassNotFoundException 
{
    return loadClass(name, false);
}

/*
使用指定类的二进制名称加载类。该方法的默认搜索类实现顺序为：该方法的默认实现按照以下顺序搜索类:
    1. 调用 findLoadedClass(String) 来检查类是否已经加载。
    2. 调用父类的类加载器上的 loadClass 方法。如果父类为空，则使用虚拟机内置的类加载器。
    3. 调用 findClass(String) 方法来查找类。
如果使用上述步骤找到了类，并且 resolve 标志为 true，则该方法将在生成的 Class 对象上调用 resolveClass(class) 方法。
鼓励 ClassLoader 的子类重写 findClass(String)，而不是这个方法。
除非重写，否则该方法在整个类加载过程中使用 getClassLoadingLock 方法返回的结果作为锁来进行同步。
Params:
    name – 类二进制名称
    resolve – 如果为真，则解析类
Returns:
    产生的 Class 对象
Throws:
    ClassNotFoundException – 如果类没有被找到
*/
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    // 实际调用为 native 的 findBootstrapClass(name)
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }

            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                long t1 = System.nanoTime();
                c = findClass(name);

                // this is the defining class loader; record the stats
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```
代码中推荐重写子类的`findClass(String)`方法，不推荐重写`loadClass(String name, boolean resolve)`方法。

### findClass(...)方法

#### 源码解读

该方法的默认实现是抛出 `ClassNotFoundException` 异常，这意味着需要其子类来实现该类。

源代码如下：

```java
/*
查找具有指定二进制名称的类。 这个方法应该被类加载器实现类重写，该实现遵循类加载的委托模型，并将在检查请求类的父类加载器后由loadClass方法调用。默认实现抛出一个ClassNotFoundException 异常。
Params:
    name – 类二进制名称
Returns:
    产生的 Class 对象
Throws:
    ClassNotFoundException – 如果类没有被找到
Since:
    1.2
*/
protected Class<?> findClass(String name) throws ClassNotFoundException {
    throw new ClassNotFoundException(name);
}
```

### defineClass(...)方法

defineClass(...) 有4个重载方法，分别为：

    defineClass(byte[] b, int off, int len) 已被遗弃

    defineClass(String name, byte[] b, int off, int len)

    defineClass(String name, byte[] b, int off, int len,  ProtectionDomain protectionDomain)

    defineClass(String name, java.nio.ByteBuffer b, ProtectionDomain protectionDomain)

#### 源码解读

```java
/*
Converts an array of bytes into an instance of class Class. Before the Class can be used it must be resolved. This method is deprecated in favor of the version that takes a binary name as its first argument, and is more secure.
Deprecated
    Replaced by defineClass(String, byte[], int, int)
Params:
    b – The bytes that make up the class data. The bytes in positions off through off+len-1 should have the format of a valid class file as defined by The Java™ Virtual Machine Specification.
    off – The start offset in b of the class data
    len – The length of the class data
Returns:
    The Class object that was created from the specified class data
Throws:
    ClassFormatError – If the data did not contain a valid class
    IndexOutOfBoundsException – If either off or len is negative, or if off+len is greater than b.length.
    SecurityException – If an attempt is made to add this class to a package that contains classes that were signed by a different set of certificates than this class, or if an attempt is made to define a class in a package with a fully-qualified name that starts with "java.".
See Also:
    loadClass(String, boolean), resolveClass(Class)
*/
@Deprecated
protected final Class<?> defineClass(byte[] b, int off, int len) throws ClassFormatError
{
    return defineClass(null, b, off, len, null);
}
```

```java
/*
Converts an array of bytes into an instance of class Class. Before the Class can be used it must be resolved.
This method assigns a default ProtectionDomain to the newly defined class. The ProtectionDomain is effectively granted the same set of permissions returned when Policy.getPolicy().getPermissions(new CodeSource(null, null)) is invoked. The default domain is created on the first invocation of defineClass, and re-used on subsequent invocations.
To assign a specific ProtectionDomain to the class, use the defineClass method that takes a ProtectionDomain as one of its arguments.
Params:
    name – The expected binary name of the class, or null if not known
    b – The bytes that make up the class data. The bytes in positions off through off+len-1 should have the format of a valid class file as defined by The Java™ Virtual Machine Specification.
    off – The start offset in b of the class data
    len – The length of the class data
Returns:
    The Class object that was created from the specified class data.
Throws:
    ClassFormatError – If the data did not contain a valid class
    IndexOutOfBoundsException – If either off or len is negative, or if off+len is greater than b.length.
    SecurityException – If an attempt is made to add this class to a package that contains classes that were signed by a different set of certificates than this class (which is unsigned), or if name begins with "java.".
Since:
    1.1
See Also:
    loadClass(String, boolean), resolveClass(Class), CodeSource, java.security.SecureClassLoader
*/
protected final Class<?> defineClass(String name, byte[] b, int off, int len) throws ClassFormatError
{
    return defineClass(name, b, off, len, null);
}

```

```java
/*
Converts an array of bytes into an instance of class Class, with an optional ProtectionDomain. If the domain is null, then a default domain will be assigned to the class as specified in the documentation for defineClass(String, byte[], int, int). Before the class can be used it must be resolved.
The first class defined in a package determines the exact set of certificates that all subsequent classes defined in that package must contain. The set of certificates for a class is obtained from the CodeSource within the ProtectionDomain of the class. Any classes added to that package must contain the same set of certificates or a SecurityException will be thrown. Note that if name is null, this check is not performed. You should always pass in the binary name of the class you are defining as well as the bytes. This ensures that the class you are defining is indeed the class you think it is.
The specified name cannot begin with "java.", since all classes in the "java.* packages can only be defined by the bootstrap class loader. If name is not null, it must be equal to the binary name of the class specified by the byte array "b", otherwise a NoClassDefFoundError will be thrown.
Params:
    name – The expected binary name of the class, or null if not known
    b – The bytes that make up the class data. The bytes in positions off through off+len-1 should have the format of a valid class file as defined by The Java™ Virtual Machine Specification.
    off – The start offset in b of the class data
    len – The length of the class data
    protectionDomain – The ProtectionDomain of the class
Returns:
    The Class object created from the data, and optional ProtectionDomain.
Throws:
    ClassFormatError – If the data did not contain a valid class
    NoClassDefFoundError – If name is not equal to the binary name of the class specified by b
    IndexOutOfBoundsException – If either off or len is negative, or if off+len is greater than b.length.
    SecurityException – If an attempt is made to add this class to a package that contains classes that were signed by a different set of certificates than this class, or if name begins with "java.".
*/
protected final Class<?> defineClass(String name, byte[] b, int off, int len,
                                        ProtectionDomain protectionDomain) throws ClassFormatError
{
    protectionDomain = preDefineClass(name, protectionDomain);
    String source = defineClassSourceLocation(protectionDomain);
    Class<?> c = defineClass1(name, b, off, len, protectionDomain, source);
    postDefineClass(c, protectionDomain);
    return c;
}
```

```java
/*
Converts a ByteBuffer into an instance of class Class, with an optional ProtectionDomain. If the domain is null, then a default domain will be assigned to the class as specified in the documentation for defineClass(String, byte[], int, int). Before the class can be used it must be resolved.
The rules about the first class defined in a package determining the set of certificates for the package, and the restrictions on class names are identical to those specified in the documentation for defineClass(String, byte[], int, int, ProtectionDomain).
An invocation of this method of the form cl.defineClass(name, bBuffer, pd) yields exactly the same result as the statements
... byte[] temp = new byte[bBuffer.remaining()]; bBuffer.get(temp); return cl.defineClass(name, temp, 0, temp.length, pd); 
Params:
    name – The expected binary name. of the class, or null if not known
    b – The bytes that make up the class data. The bytes from positions b.position() through b.position() + b.limit() -1 should have the format of a valid class file as defined by The Java™ Virtual Machine Specification.
    protectionDomain – The ProtectionDomain of the class, or null.
Returns:
    The Class object created from the data, and optional ProtectionDomain.
Throws:
    ClassFormatError – If the data did not contain a valid class.
    NoClassDefFoundError – If name is not equal to the binary name of the class specified by b
    SecurityException – If an attempt is made to add this class to a package that contains classes that were signed by a different set of certificates than this class, or if name begins with "java.".
Since:
    1.5
See Also:
    defineClass(String, byte[], int, int, ProtectionDomain)
*/
protected final Class<?> defineClass(String name, java.nio.ByteBuffer b,
                                        ProtectionDomain protectionDomain) throws ClassFormatError
{
    int len = b.remaining();

    // Use byte[] if not a direct ByteBufer:
    if (!b.isDirect()) {
        if (b.hasArray()) {
            return defineClass(name, b.array(),
                                b.position() + b.arrayOffset(), len,
                                protectionDomain);
        } else {
            // no array, or read-only array
            byte[] tb = new byte[len];
            b.get(tb);  // get bytes out of byte buffer.
            return defineClass(name, tb, 0, len, protectionDomain);
        }
    }

    protectionDomain = preDefineClass(name, protectionDomain);
    String source = defineClassSourceLocation(protectionDomain);
    Class<?> c = defineClass2(name, b, b.position(), len, protectionDomain, source);
    postDefineClass(c, protectionDomain);
    return c;
}
```

## 双亲委派模型

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它所搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

### Bootstrap Class Loader

该类加载器负责加载存放在 `<JAVA_HOME>/lib` 目录，或者被 `-Xbootclasspath` 参数所指定的路径存放的，而且是 Java 虚拟机能够识别的类库中的类库。Java 虚拟机按照文件名来识别，如 rt.jar、tools.jar，名字不符合的类库即使放在 lib 目录中也不会被加载。

### Extension Class Loader

该类加载器对应的的 Java 类为 `sun.misc.Lanucher$ExtCLassLoader`，它负责加载 `<JAVA_HOME>/lib/ext` 目录中，或者被 `java.ext.dirs` 系统变量所指定的路径中所有的类库。 

### Application Class Loader

该类加载器对应的的 Java 类为 `sun.misc.Lanucher$AppCLassLoader`，它负责加载用户类路径 `ClassPath` 上的所有类库，或者被 `java.ext.dirs` 系统变量所指定的路径中所有的类库。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

### 双亲委派模型图解


### Launcher

`Launcher`类由`BootstrapClassLoader加载`负责加载，在加载时会自动创建一个`Launcher`实例对象。源代码如下：

```java
...
// 类变量
private static Launcher launcher = new Launcher();
...
```

在构造方法中完成了 应用程序类加载器 和 扩展类加载器 的创建与设置。源代码如下：

```java
public Launcher() {
    Launcher.ExtClassLoader var1;
    try {
        // 创建扩展类加载器
        var1 = Launcher.ExtClassLoader.getExtClassLoader();
    } catch (IOException var10) {
        throw new InternalError("Could not create extension class loader", var10);
    }

    try {
        // 创建应用程序类加载器
        this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
    } catch (IOException var9) {
        throw new InternalError("Could not create application class loader", var9);
    }

    // 设置当前线程的类加载器为应用程序类加载器，设置后该线程中使用的所有类都由该类加载器加载
    Thread.currentThread().setContextClassLoader(this.loader);
    String var2 = System.getProperty("java.security.manager");
    if (var2 != null) {
        SecurityManager var3 = null;
        if (!"".equals(var2) && !"default".equals(var2)) {
            try {
                var3 = (SecurityManager)this.loader.loadClass(var2).newInstance();
            } catch (IllegalAccessException var5) {
            } catch (InstantiationException var6) {
            } catch (ClassNotFoundException var7) {
            } catch (ClassCastException var8) {
            }
        } else {
            var3 = new SecurityManager();
        }

        if (var3 == null) {
            throw new InternalError("Could not create SecurityManager: " + var2);
        }

        System.setSecurityManager(var3);
    }

}
```


## 破坏双清委派模型

## Thread.contextClassLoader

## 参考资料

深入理解Java虚拟机 - 周志明

[老大难的 Java ClassLoader，到了该彻底理解它的时候了](http://blog.itpub.net/31561269/viewspace-2222522/ ) - 码洞


## 相关blog

[类加载时机](./类加载时机.md)

[类加载过程](./类加载过程.md)